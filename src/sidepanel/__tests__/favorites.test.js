/**\n * Tests unitarios para FavoritesManager\n * Siguiendo protocolos de testing obligatorios\n * \n * @author Kit IA Emprendedor\n * @version 1.0.0\n * @since 2025-01-21\n */\n\nimport { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport { FavoritesManager, FAVORITES_CONFIG } from '../modules/favorites.js';\n\n// Mock de Chrome Storage API\nconst mockStorage = {\n  data: {},\n  get: vi.fn((key) => {\n    return Promise.resolve({ [key]: mockStorage.data[key] });\n  }),\n  set: vi.fn((obj) => {\n    Object.assign(mockStorage.data, obj);\n    return Promise.resolve();\n  }),\n  clear: vi.fn(() => {\n    mockStorage.data = {};\n    return Promise.resolve();\n  })\n};\n\n// Mock global chrome\nglobal.chrome = {\n  storage: {\n    local: mockStorage\n  },\n  runtime: {\n    id: 'test-extension-id'\n  }\n};\n\n// Console mocks para tests limpios\nconst originalConsole = { ...console };\n\ndescribe('FavoritesManager', () => {\n  let manager;\n\n  beforeEach(() => {\n    // Reset storage mock\n    mockStorage.data = {};\n    mockStorage.get.mockClear();\n    mockStorage.set.mockClear();\n    mockStorage.clear.mockClear();\n    \n    // Crear nueva instancia para cada test\n    manager = new FavoritesManager();\n    \n    // Suprimir logs durante tests\n    console.log = vi.fn();\n    console.error = vi.fn();\n  });\n\n  afterEach(() => {\n    // Restaurar console\n    Object.assign(console, originalConsole);\n  });\n\n  describe('Inicialización', () => {\n    it('debe inicializarse correctamente con storage vacío', async () => {\n      const result = await manager.init();\n      \n      expect(result).toBe(true);\n      expect(manager.initialized).toBe(true);\n      expect(manager.getCount()).toBe(0);\n      expect(mockStorage.get).toHaveBeenCalledWith('favorites');\n    });\n\n    it('debe cargar favoritos existentes desde storage', async () => {\n      const existingFavorites = ['gpt-1', 'gpt-2', 'gpt-3'];\n      mockStorage.data.favorites = existingFavorites;\n      \n      await manager.init();\n      \n      expect(manager.getCount()).toBe(3);\n      expect(manager.isFavorite('gpt-1')).toBe(true);\n      expect(manager.isFavorite('gpt-2')).toBe(true);\n      expect(manager.isFavorite('gpt-3')).toBe(true);\n      expect(manager.getAll()).toEqual(expect.arrayContaining(existingFavorites));\n    });\n\n    it('debe filtrar IDs inválidos durante la inicialización', async () => {\n      const mixedData = ['gpt-1', '', null, undefined, 'gpt-2', 123, 'gpt-3'];\n      mockStorage.data.favorites = mixedData;\n      \n      await manager.init();\n      \n      expect(manager.getCount()).toBe(3);\n      expect(manager.getAll()).toEqual(['gpt-1', 'gpt-2', 'gpt-3']);\n    });\n\n    it('debe manejar storage corrupto graciosamente', async () => {\n      mockStorage.data.favorites = 'not-an-array';\n      \n      const result = await manager.init();\n      \n      expect(result).toBe(true);\n      expect(manager.getCount()).toBe(0);\n    });\n\n    it('debe aplicar límite máximo durante inicialización', async () => {\n      const tooManyFavorites = Array.from(\n        { length: FAVORITES_CONFIG.MAX_FAVORITES + 10 }, \n        (_, i) => `gpt-${i}`\n      );\n      mockStorage.data.favorites = tooManyFavorites;\n      \n      await manager.init();\n      \n      expect(manager.getCount()).toBe(FAVORITES_CONFIG.MAX_FAVORITES);\n    });\n\n    it('no debe permitir doble inicialización', async () => {\n      await manager.init();\n      const result = await manager.init();\n      \n      expect(result).toBe(true);\n      expect(mockStorage.get).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('Gestión de favoritos', () => {\n    beforeEach(async () => {\n      await manager.init();\n    });\n\n    describe('isFavorite()', () => {\n      it('debe retornar false para GPT no favorito', () => {\n        expect(manager.isFavorite('gpt-unknown')).toBe(false);\n      });\n\n      it('debe retornar true para GPT favorito', async () => {\n        await manager.add('gpt-1');\n        expect(manager.isFavorite('gpt-1')).toBe(true);\n      });\n\n      it('debe lanzar error si no está inicializado', () => {\n        const uninitializedManager = new FavoritesManager();\n        expect(() => uninitializedManager.isFavorite('gpt-1'))\n          .toThrow('FavoritesManager not initialized');\n      });\n\n      it('debe validar GPT ID', () => {\n        expect(() => manager.isFavorite('')).toThrow('GPT ID must be a non-empty string');\n        expect(() => manager.isFavorite(null)).toThrow('GPT ID must be a non-empty string');\n        expect(() => manager.isFavorite(123)).toThrow('GPT ID must be a non-empty string');\n      });\n    });\n\n    describe('toggle()', () => {\n      it('debe agregar GPT no favorito', async () => {\n        const result = await manager.toggle('gpt-1');\n        \n        expect(result).toBe(true);\n        expect(manager.isFavorite('gpt-1')).toBe(true);\n        expect(manager.getCount()).toBe(1);\n        expect(mockStorage.set).toHaveBeenCalled();\n      });\n\n      it('debe remover GPT favorito', async () => {\n        await manager.add('gpt-1');\n        const result = await manager.toggle('gpt-1');\n        \n        expect(result).toBe(false);\n        expect(manager.isFavorite('gpt-1')).toBe(false);\n        expect(manager.getCount()).toBe(0);\n      });\n\n      it('debe manejar múltiples toggles correctamente', async () => {\n        // Toggle 1: agregar\n        let result = await manager.toggle('gpt-1');\n        expect(result).toBe(true);\n        \n        // Toggle 2: remover\n        result = await manager.toggle('gpt-1');\n        expect(result).toBe(false);\n        \n        // Toggle 3: agregar nuevamente\n        result = await manager.toggle('gpt-1');\n        expect(result).toBe(true);\n      });\n\n      it('debe respetar límite máximo', async () => {\n        // Llenar hasta el límite\n        for (let i = 0; i < FAVORITES_CONFIG.MAX_FAVORITES; i++) {\n          await manager.add(`gpt-${i}`);\n        }\n        \n        // Intentar agregar uno más\n        await expect(manager.toggle('gpt-overflow'))\n          .rejects.toThrow('Maximum favorites limit reached');\n      });\n    });\n\n    describe('add()', () => {\n      it('debe agregar nuevo favorito', async () => {\n        const result = await manager.add('gpt-1');\n        \n        expect(result).toBe(true);\n        expect(manager.isFavorite('gpt-1')).toBe(true);\n      });\n\n      it('debe retornar false si ya es favorito', async () => {\n        await manager.add('gpt-1');\n        const result = await manager.add('gpt-1');\n        \n        expect(result).toBe(false);\n      });\n\n      it('debe respetar límite máximo', async () => {\n        // Llenar hasta el límite\n        for (let i = 0; i < FAVORITES_CONFIG.MAX_FAVORITES; i++) {\n          await manager.add(`gpt-${i}`);\n        }\n        \n        await expect(manager.add('gpt-overflow'))\n          .rejects.toThrow('Maximum favorites limit reached');\n      });\n    });\n\n    describe('remove()', () => {\n      it('debe remover favorito existente', async () => {\n        await manager.add('gpt-1');\n        const result = await manager.remove('gpt-1');\n        \n        expect(result).toBe(true);\n        expect(manager.isFavorite('gpt-1')).toBe(false);\n      });\n\n      it('debe retornar false si no es favorito', async () => {\n        const result = await manager.remove('gpt-nonexistent');\n        expect(result).toBe(false);\n      });\n    });\n\n    describe('getAll()', () => {\n      it('debe retornar array vacío inicialmente', () => {\n        expect(manager.getAll()).toEqual([]);\n      });\n\n      it('debe retornar todos los favoritos', async () => {\n        await manager.add('gpt-1');\n        await manager.add('gpt-2');\n        await manager.add('gpt-3');\n        \n        const favorites = manager.getAll();\n        expect(favorites).toHaveLength(3);\n        expect(favorites).toEqual(expect.arrayContaining(['gpt-1', 'gpt-2', 'gpt-3']));\n      });\n    });\n\n    describe('clear()', () => {\n      it('debe limpiar todos los favoritos', async () => {\n        await manager.add('gpt-1');\n        await manager.add('gpt-2');\n        \n        await manager.clear();\n        \n        expect(manager.getCount()).toBe(0);\n        expect(manager.getAll()).toEqual([]);\n        expect(mockStorage.set).toHaveBeenCalledWith({ favorites: [] });\n      });\n    });\n  });\n\n  describe('Import/Export', () => {\n    beforeEach(async () => {\n      await manager.init();\n    });\n\n    describe('import()', () => {\n      it('debe importar favoritos válidos', async () => {\n        const importData = ['gpt-1', 'gpt-2', 'gpt-3'];\n        const result = await manager.import(importData);\n        \n        expect(result).toBe(3);\n        expect(manager.getAll()).toEqual(expect.arrayContaining(importData));\n      });\n\n      it('debe filtrar datos inválidos durante import', async () => {\n        const mixedData = ['gpt-1', '', null, 'gpt-2', 123, undefined];\n        const result = await manager.import(mixedData);\n        \n        expect(result).toBe(2);\n        expect(manager.getAll()).toEqual(['gpt-1', 'gpt-2']);\n      });\n\n      it('debe aplicar límite máximo durante import', async () => {\n        const tooManyFavorites = Array.from(\n          { length: FAVORITES_CONFIG.MAX_FAVORITES + 10 }, \n          (_, i) => `gpt-${i}`\n        );\n        \n        const result = await manager.import(tooManyFavorites);\n        expect(result).toBe(FAVORITES_CONFIG.MAX_FAVORITES);\n      });\n\n      it('debe lanzar error con datos no-array', async () => {\n        await expect(manager.import('not-an-array'))\n          .rejects.toThrow('Import data must be an array');\n      });\n\n      it('debe reemplazar favoritos existentes', async () => {\n        await manager.add('gpt-old');\n        await manager.import(['gpt-new1', 'gpt-new2']);\n        \n        expect(manager.isFavorite('gpt-old')).toBe(false);\n        expect(manager.isFavorite('gpt-new1')).toBe(true);\n        expect(manager.isFavorite('gpt-new2')).toBe(true);\n      });\n    });\n\n    describe('export()', () => {\n      it('debe exportar favoritos como array', async () => {\n        await manager.add('gpt-1');\n        await manager.add('gpt-2');\n        \n        const exported = manager.export();\n        expect(Array.isArray(exported)).toBe(true);\n        expect(exported).toEqual(expect.arrayContaining(['gpt-1', 'gpt-2']));\n      });\n\n      it('debe retornar array vacío si no hay favoritos', () => {\n        const exported = manager.export();\n        expect(exported).toEqual([]);\n      });\n    });\n  });\n\n  describe('Event Listeners', () => {\n    beforeEach(async () => {\n      await manager.init();\n    });\n\n    it('debe notificar cambios a listeners', async () => {\n      const listener = vi.fn();\n      const unsubscribe = manager.onChange(listener);\n      \n      await manager.add('gpt-1');\n      \n      expect(listener).toHaveBeenCalledWith(['gpt-1']);\n      \n      unsubscribe();\n    });\n\n    it('debe permitir des-registrar listeners', async () => {\n      const listener = vi.fn();\n      const unsubscribe = manager.onChange(listener);\n      \n      unsubscribe();\n      await manager.add('gpt-1');\n      \n      expect(listener).not.toHaveBeenCalled();\n    });\n\n    it('debe manejar errores en listeners graciosamente', async () => {\n      const faultyListener = vi.fn(() => {\n        throw new Error('Listener error');\n      });\n      \n      manager.onChange(faultyListener);\n      \n      // No debe lanzar error\n      expect(async () => {\n        await manager.add('gpt-1');\n      }).not.toThrow();\n    });\n\n    it('debe validar callback de listener', () => {\n      expect(() => manager.onChange('not-a-function'))\n        .toThrow('Callback must be a function');\n    });\n  });\n\n  describe('Storage y Persistencia', () => {\n    beforeEach(async () => {\n      await manager.init();\n    });\n\n    it('debe persistir cambios en storage', async () => {\n      await manager.add('gpt-1');\n      \n      expect(mockStorage.set).toHaveBeenCalledWith({\n        favorites: ['gpt-1']\n      });\n    });\n\n    it('debe manejar errores de storage graciosamente', async () => {\n      mockStorage.set.mockRejectedValueOnce(new Error('Storage error'));\n      \n      // No debe lanzar error\n      const result = await manager.add('gpt-1');\n      expect(result).toBe(true); // Operación local exitosa\n    });\n\n    it('debe usar debounce para múltiples cambios rápidos', async () => {\n      // Simular múltiples cambios rápidos\n      await Promise.all([\n        manager.add('gpt-1'),\n        manager.add('gpt-2'),\n        manager.add('gpt-3')\n      ]);\n      \n      // Debería haber menos llamadas a storage que operaciones\n      expect(mockStorage.set.mock.calls.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Validaciones y Edge Cases', () => {\n    beforeEach(async () => {\n      await manager.init();\n    });\n\n    it('debe manejar IDs con espacios', async () => {\n      const result = await manager.add('  gpt-1  ');\n      expect(result).toBe(true);\n      expect(manager.isFavorite('  gpt-1  ')).toBe(true);\n    });\n\n    it('debe manejar IDs especiales válidos', async () => {\n      const specialIds = ['gpt-1', 'gpt_2', 'gpt.3', 'gpt-special-chars-123'];\n      \n      for (const id of specialIds) {\n        await manager.add(id);\n        expect(manager.isFavorite(id)).toBe(true);\n      }\n    });\n\n    it('debe tener métodos de estadísticas', () => {\n      const stats = manager.getStats();\n      \n      expect(stats).toHaveProperty('initialized');\n      expect(stats).toHaveProperty('count');\n      expect(stats).toHaveProperty('maxLimit');\n      expect(stats).toHaveProperty('listeners');\n      expect(stats).toHaveProperty('saving');\n    });\n  });\n\n  describe('Performance y Límites', () => {\n    beforeEach(async () => {\n      await manager.init();\n    });\n\n    it('debe tener operaciones O(1) para verificación', () => {\n      // Agregar muchos favoritos\n      const promises = [];\n      for (let i = 0; i < 1000; i++) {\n        promises.push(manager.add(`gpt-${i}`));\n      }\n      \n      return Promise.all(promises).then(() => {\n        // Verificación debe ser rápida independiente del tamaño\n        const start = performance.now();\n        manager.isFavorite('gpt-500');\n        const end = performance.now();\n        \n        expect(end - start).toBeLessThan(1); // < 1ms\n      });\n    });\n\n    it('debe respetar configuración de límites', () => {\n      expect(FAVORITES_CONFIG.MAX_FAVORITES).toBeGreaterThan(0);\n      expect(FAVORITES_CONFIG.SYNC_DELAY).toBeGreaterThan(0);\n      expect(FAVORITES_CONFIG.STORAGE_KEY).toBe('favorites');\n    });\n  });\n});